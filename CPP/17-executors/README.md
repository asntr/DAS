# Executors framework

## Введение

В задачах первого семинара вам нужно было распараллелить вычисления задач.
Если немного обобщить, то код всех ваших решений выглядел примерно так:

```c++

class Output;
class Input;

Output Compute(const Input& inputs) {
    // Select concurrency level
    int num_threads = std::thread::hardware_concurrency();

    // Split input into tasks
    std::vector<Tasks> tasks = SplitIntoSubtasks(inputs, num_threads);

    // Launch threads
    std::vector<std::thread> threads;
    for (int i = 0; i < num_threads; ++i) {
        threads.emplace_back([i, &inputs, &tasks] {
            ComputeSubtask(&tasks[i], input);
        });
    }

    // Join all threads
    for (auto& t : threads) t.join();

    // Aggregate
    return Aggregate(tasks, input);
}
```

Если внимательно посмотреть на код, то можно заметить, что в нём смешаны 2
независимых действия:
  
    1. Большая задача разбивается на небольшие независимые подзадачи. Затем
       решения подзадач объединяются вместе. Этот код специфичен для каждого алгоритма.

    2. Код решает сколько потоков запускать, как их запускать и когда
       их завершать. Этот код везде одинаковый.

С первым пунктом все хорошо, а вот со вторым есть проблемы.

  * Пользователь не может контролировать сколько потоков будет запущено.
    _Код действует эгоистично и занимает все ядра на машине._

  * Неудобно использовать такой код внутри другого параллельного алгоритма.
    _Например если на первом уровне разобъем задачу на 10 частей и каждую захотим решить с помощью `Compute()`, то у нас запустится `10 * hardware concurrency` потоков._

  * Нельзя отменить вычисление, нельзя следить за прогрессом.

Все проблемы появляются из того, что код сам занимается созданием
потоков. Мы хотим вынести это решение на самый высокий уровень, а в
коде оставить только разбиение на независимые подзадачи. В этом
задании вам нужно написать библиотеку помогающую выполнить такое разделение.

### Executors и Tasks

**Disclaimer:** интерфейсы Task и VeryExecutor в этой задаче не претендуют
  на элегантность и эффективность.

  * `Task` - это какой-то кусок вычислений. Сам код вычисления находится в
  методе run() и определяется пользователем.
  * `VeryExecutor` - это набор потоков, которые могут выполнять `Task`-и. 
  * `VeryExecutor` *должен* запускать потоки в конструкторе, во время работы новых потоков создаваться не должно.
  * Чтобы начать выполнять `Task`, пользователь должен отправить его в `VeryExecutor` с помощью метода
  `submit()`.
  * После этого, пользователь может дождаться пока `Task` завершится, позвав метод `Task::wait`.

  ```c++
  class MyPrimeSplittingTask : public Task {
      Params params_;
  public:
      MyPrimeSplittingTask(Params params) : params_(params) {}
      bool is_prime = false;
      virtual void run() {
          is_prime = check_is_prime(params_);
      }
  }

  bool doComputation(std::shared_ptr<VeryExecutor> pool, Params params) {
      auto my_task = std::make_shared<MyPrimeSplittingTask>(params);
      pool->submit(my_task);
      my_task.wait();
      return my_task->is_prime;
  }
  ```

  * `Task` может завершиться успешно (`isCompleted`), с ошибкой
    (`isFailed`) и быть отменён (`isCanceled`). После того, как с ним
    произошло одно из этих событий - он считается выполненным
    (`isFinished`).

  * Пользователь может в любой момент отменить `Task` с помощью метода
    `cancel()`. В этом случае, если выполнение `Task`а еще не
    началось, то оно и не должно начаться.

  * `Task` может иметь зависимости. Например в задаче reduce сначала
    должны были выполниться reduce-ы по кускам вектора, а потом один
    финальный reduce по промежуточным значениям. Пользователь может
    сказать, что один `Task` должен выполняться только после того как
    выполнился какой-то другой `Task`, позвав метод
    `Task::addDependency`.

  * `Task` может иметь триггеры (`Task::addTrigger`). В таком случае он должен начать
    выполнение после того как хотя бы один триггер завершился.

  * `Task` может иметь один триггер по времени
    (`Task::setTimeTrigger`). В этом случае он должен начать
    выполнение если наступило время `deadline`.

  * В общем случае, `VeryExecutor::submit` не должен начинать выполнение
  сразу, а дожидаться условия:
      - _Или_ все зависимости выполнились
      - _Или_ один из триггеров выполнился
      - _Или_ выставлен `deadline`, и наступило время `deadline`.

  * `VeryExecutor` предоставляет API для того, чтобы остановить выполнение.
      - `VeryExecutor::startShutdown` - начинает процесс остановки. Таски, которые 
        были посланы после `startShutdown` должны сразу переходить в состояние canceled.
      - `VeryExecutor::waitShutdown` - блокируется, пока VeryExecutor не остановится.
      - `VeryExecutor::~VeryExecutor` - неявно делает shutdown и дожидается завершения потоков.

### Futures

Интерфейсы `Task` и `VeryExecutor` являются довольно многословными, во второй
части задания вам нужно будет реализовать класс `Future` и несколько комбинаторов к нему.

  * `Future` - это `Task`, у которого есть результат (какое-то значение).

  * Интерфейсы комбинаторов определены в классе `VeryExecutor`:
    - `invoke(cb)` - выполнить `cb` внутри `VeryExecutor`-а, результат вернуть через `Future`.
    - `then(input, cb)` - выполнить `cb`, после того как закончится `input`.
    - `whenAll(vector<FuturePtr<T>> ) -> FuturePtr<vector<T>>` - собирает результат нескольких `Future` в один.
    - `whenFirst(vector<FuturePtr<T>>) -> FuturePtr<T>` - возвращает результат, который появится первым.
    - `whenAllBeforeDeadline(vector<FuturePtr<T>>, deadline) -> FuturePtr<vector<T>>` - возвращает все результаты, которые успели появиться до deadline.

## Задание

 * Вам нужно реализовать и протестировать описанный выше интерфейс и
   защитить свой код на CodeReview.
 * Задание оценивается в 10 баллов максимум. Чтобы претендовать на
   положительную оценку нужно реализовать весь интерфейс целиком.
 * После этого код должен пройти review. На review оценивается качество
   кода и качество тестов.

## Review кода

**Внимание:** Чтобы послать код на ревью, нужно создать merge-request,
  который отражает ваше решение. Для этого нужно весь код из этого
  задания коммитить локально в отдельную ветку. Иначе в review
  появится код, не относящийся к этому заданию.

  * В самом начале выполните команды:
```bash
git push private master:17-executors-pre # выложить состояние кода в начале.
git checkout -b 17-executors # создать локально новую ветку
```

  * Чтобы послать код на review, выполните команды:
```bash
git commit -m "Commit description"
git push private 17-executors
```
    После этого в веб-интерфейсе создайте merge-request из `17-executors` в
   `17-executors-pre` и повесьте его (поле assignee) на @slon.

 * Если вы захотите посдавать семинары, переключитесь обратно в ветку
  `master`, закоммитив перед этим промежуточные изменения или воспользовавшись прятанием `git stash`.

## Советы по реализации

  0. Эта задача идеально ложится на TDD, поэтому мы не даём вам
     тесты. Пользуйтесь этой возможностью :) Тестов должно быть много,
     и они должны покрывать независимые случаи. Если вы пришлёте нам
     на review один тест, в котором проверяется все-все-все - много
     баллов вы за него не получите. _Нам не важно сделали ли вы_
     _баги, нам важно что вы сделали чтобы багов небыло._
  1. Продумайте какие lock-и вам потребуются. Как сделать так, чтобы
     в них не было циклов?
  2. Продумайте в каких состояниях может находиться `Task`. Вставьте в
     код `assert`-ы.
  3. Начните с базового функционала: `Task`-и `VeryExecutor` без
     зависимостей и триггеров. Затем реализуйте зависимости и
     триггеры, поверх этого реализуйте `Future` и комбинаторы.
  4. Для реализации `Task::setTimerTrigger` вам потребуется использовать метод
     `wait_until` у `std::condition_variable`.
  5. Для эффективной реализации таймеров нужно использовать кучу.
  6. Мы дадим вам бонус баллы, если в решении будет опциональное verbose логирование. 
     [asio](http://www.boost.org/doc/libs/1_63_0/doc/html/boost_asio.html#boost_asio.overview.core.handler_tracking).
  7. Если вам совсем непонятно, как это делать - посмотрите [спойлер](spoiler.md).