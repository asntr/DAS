# Meet-in-the-middle

В этой задаче вам предстоит применить метод _Meet-in-the-middle_ для поиска коллизии для заданной хеш-функции и строки.

Вам дана параметризованная полиномиальная хеш-функция строки $`h_{m, p}(s)`$ (где $`m`$ --- простое), с которой вы уже сталкивались в 1-ом семестре:
```math
h_{m, p}(s) = \sum_{i=1}^{|s|} s_i \cdot p^{|s| - i} \; (mod\, m).
```

Реализация этой функции приведена в файле `hasher.h`.

Вы должны реализовать функцию `find_collision` в файле `find_collision.cpp`, которая по
заданной строке $`s`$ и параметрам $`m`$, $`p`$ (которые упакованы в объекте класса `Hasher`),
находит $`s' \ne s`$ такую, что $`h_{m, p}(s) = h_{m, p}(s')`$.

Длина $`s'`$ не должна превосходить 14 символов и соответствовать выражению `[_a-zA-Z0-9]+`, т.е.
содержать только буквы, цифры и _.

Класс `Hasher` подразумевает, что $`m \cdot p`$ помещается в `int64_t`. В частности, в этой задаче $`m \le 10^{14}`$. $`m`$ является простым, а $`p`$ --- нечетным.

### Подсказки и полезные ссылки
* Описание метода можно найти [здесь](https://neerc.ifmo.ru/wiki/index.php?title=Meet-in-the-middle).
* Предположим, вы знаете значение $`h(s_{pref} + s_{suf}) = T`$. Можно ли, зная это $`T`$ и $`s_{suf}`$ найти $`h(s_{pref})`$?
* https://en.wikipedia.org/wiki/Modular_multiplicative_inverse
* http://en.cppreference.com/w/cpp/atomic/atomic
* http://stackoverflow.com/questions/9685486/unordered-map-thread-safety
* Для начала лучше написать однопоточную версию решения

### Ограничения
Объем потребляемой памяти на тестах не должен превышать 32 Мб.

Время выполнения бенчмарка не должно превышать 10 секунд, а объем потребляемой памяти 1 Гб.

### Лидерборд
score считается как $`\frac{r_i}{t_i}`$, где $`t_i`$ --- real-time вашего решения, а $`r_i`$ --- нашего базового.